$date
	Fri Dec  3 01:02:40 2021
$end
$version
	Icarus Verilog
$end
$timescale
	10ps
$end
$scope module microc_tb $end
$var wire 1 ! t_z $end
$var wire 6 " t_opcode [5:0] $end
$var reg 1 # clk $end
$var reg 1 $ reset $end
$var reg 3 % t_op [2:0] $end
$var reg 1 & t_s_inc $end
$var reg 1 ' t_s_inm $end
$var reg 1 ( t_s_ret $end
$var reg 1 ) t_s_rre $end
$var reg 1 * t_we3 $end
$var reg 1 + t_wez $end
$scope module t_microc $end
$var wire 8 , INM [7:0] $end
$var wire 1 # clk $end
$var wire 10 - const1 [9:0] $end
$var wire 3 . op [2:0] $end
$var wire 1 $ reset $end
$var wire 1 & s_inc $end
$var wire 1 ' s_inm $end
$var wire 1 ( s_ret $end
$var wire 1 ) s_rre $end
$var wire 1 * we3 $end
$var wire 1 + wez $end
$var wire 1 ! z $end
$var wire 10 / sum_out [9:0] $end
$var wire 10 0 out_mux_pc [9:0] $end
$var wire 16 1 out_mem_prog [15:0] $end
$var wire 6 2 opcode [5:0] $end
$var wire 10 3 mux_to_mux [9:0] $end
$var wire 1 4 Z_ALU $end
$var wire 8 5 WD3 [7:0] $end
$var wire 10 6 RR_to_mux [9:0] $end
$var wire 8 7 RD2 [7:0] $end
$var wire 8 8 RD1 [7:0] $end
$var wire 8 9 OUT_ALU [7:0] $end
$var wire 10 : DIR_SALTO [9:0] $end
$var wire 10 ; DIR [9:0] $end
$scope module PC $end
$var wire 1 # clk $end
$var wire 1 $ reset $end
$var wire 10 < d [9:0] $end
$var reg 10 = q [9:0] $end
$upscope $end
$scope module RR $end
$var wire 1 # clk $end
$var wire 1 ) enable $end
$var wire 1 $ reset $end
$var wire 10 > d [9:0] $end
$var reg 10 ? q [9:0] $end
$upscope $end
$scope module alu1 $end
$var wire 3 @ op [2:0] $end
$var wire 8 A y [7:0] $end
$var wire 1 4 zero $end
$var wire 8 B b [7:0] $end
$var wire 8 C a [7:0] $end
$var reg 8 D s [7:0] $end
$upscope $end
$scope module bancoreg $end
$var wire 1 # clk $end
$var wire 4 E ra1 [3:0] $end
$var wire 4 F ra2 [3:0] $end
$var wire 4 G wa3 [3:0] $end
$var wire 1 * we3 $end
$var wire 8 H wd3 [7:0] $end
$var wire 8 I rd2 [7:0] $end
$var wire 8 J rd1 [7:0] $end
$upscope $end
$scope module ffz $end
$var wire 1 + carga $end
$var wire 1 # clk $end
$var wire 1 4 d $end
$var wire 1 $ reset $end
$var reg 1 ! q $end
$upscope $end
$scope module memoria $end
$var wire 10 K a [9:0] $end
$var wire 1 # clk $end
$var wire 16 L rd [15:0] $end
$upscope $end
$scope module mux_S_INC $end
$var wire 10 M d0 [9:0] $end
$var wire 1 & s $end
$var wire 10 N y [9:0] $end
$var wire 10 O d1 [9:0] $end
$upscope $end
$scope module mux_S_INM $end
$var wire 8 P d0 [7:0] $end
$var wire 8 Q d1 [7:0] $end
$var wire 1 ' s $end
$var wire 8 R y [7:0] $end
$upscope $end
$scope module mux_S_RET $end
$var wire 10 S d0 [9:0] $end
$var wire 10 T d1 [9:0] $end
$var wire 1 ( s $end
$var wire 10 U y [9:0] $end
$upscope $end
$scope module sumador $end
$var wire 10 V a [9:0] $end
$var wire 10 W b [9:0] $end
$var wire 10 X y [9:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b1 X
b0 W
b1 V
b1 U
b0 T
b1 S
bz R
bz Q
b0 P
b1 O
b1 N
b0 M
b0 L
b0 K
b0 J
b0 I
bz H
b0 G
b0 F
b0 E
b0 D
b0 C
b0 B
b0 A
b0 @
b0 ?
b1 >
b0 =
b1 <
b0 ;
b0 :
b0 9
b0 8
b0 7
b0 6
bz 5
14
b1 3
b0 2
b0 1
b1 0
b1 /
b0 .
b1 -
bz ,
0+
1*
0)
0(
1'
1&
b0 %
1$
1#
b0 "
0!
$end
#2000
0$
0#
#4000
b10 0
b10 <
b10 U
b10 3
b10 N
b10 S
b10 /
b10 >
b10 O
b10 X
b1 ;
b1 =
b1 K
b1 W
1#
#6000
0#
#8000
b1 3
b1 N
b1 S
b1 /
b1 >
b1 O
b1 X
b0 ;
b0 =
b0 K
b0 W
b10 6
b10 ?
b10 T
1#
b10 0
b10 <
b10 U
b0 5
b0 H
b0 R
1(
1)
0'
0*
#10000
0#
#12000
b1 0
b1 <
b1 U
b11 3
b11 N
b11 S
b1 6
b1 ?
b1 T
b11 /
b11 >
b11 O
b11 X
b10 ;
b10 =
b10 K
b10 W
1#
#14000
0#
#16000
1!
b1 /
b1 >
b1 O
b1 X
b0 ;
b0 =
b0 K
b0 W
1#
b0 0
b0 <
b0 U
b0 3
b0 N
b0 S
0(
0)
0&
1+
b10 %
b10 .
b10 @
1*
#18000
0#
#20000
1#
#22000
0#
#24000
1#
#26000
0#
#28000
b10 /
b10 >
b10 O
b10 X
b1 ;
b1 =
b1 K
b1 W
1#
b1 0
b1 <
b1 U
b10 3
b10 N
b10 S
1(
1&
0+
b0 %
b0 .
b0 @
0*
#30000
0#
#32000
b10 0
b10 <
b10 U
b10 6
b10 ?
b10 T
1#
1)
